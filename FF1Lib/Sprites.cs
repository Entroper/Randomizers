using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using RomUtilities;

namespace FF1Lib
{
	public partial class FF1Rom : NesRom
	{
	    // Copied from FFHackster.  The Hackster offsets included
	    // the ROM header, but FFR doesn't, so subtract that out.
	    //
	    const int CHARBATTLEPIC_OFFSET =			0x25010 - 0x10;
	    const int CHARBATTLEPALETTE_OFFSET =		0x3EBB5;
	    const int CHARBATTLEPALETTE_ASSIGNMENT1 =		0x3204C;
	    const int CHARBATTLEPALETTE_ASSIGNMENT2 =		0x3ECB4;
	    const int MAPMANPALETTE_OFFSET =			0x3B0;
	    const int MAPMANGRAPHIC_OFFSET =			0x9010 - 0x10;

	    const int MAPMAN_DOWN = 0;
	    const int MAPMAN_UP = 1;
	    const int MAPMAN_SIDE1 = 1;
	    const int MAPMAN_SIDE2 = 1;

	    public byte[] EncodeForPPU(byte[] tile) {
		// Take an array of 64 bytes with a ordinary linear
		// encoding (left to right, top to bottom, one byte
		// per pixel) and return the 16-byte, dual-plane
		// encoding used by the NES PPU.

		var ppuformat = new byte[16];

		for (int i = 0; i < 64; i++) {
		    var val = tile[i];
		    var bit0 = val & 0x01;
		    var bit1 = val >> 1;
		    var row = (i >> 3) & 0x07;
		    var col = 7 - (i & 0x07);
		    ppuformat[row] |= (byte)(bit0 << col);
		    ppuformat[row+8] |= (byte)(bit1 << col);
		}
		return ppuformat;
	    }

	    public void SetCustomPlayerSprites(Stream readStream) {
		//dlg.graphicoffset = MAPMANGRAPHIC_OFFSET + (cur_class << 8);
		//dlg.paletteoffset = -cur_class - 1;

		var newtile1 = new byte[] {
		    0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01,
		    0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		    0x00, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
		    0x00, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
		    0x00, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
		    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		};
		var newtile2 = new byte[] {
		    0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
		    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
		    0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00,
		    0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x00,
		    0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x00,
		    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
		    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
		    0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
		};
		var newtile3 = new byte[] {
		    0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
		    0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
		    0x00, 0x01, 0x00, 0x01, 0x02, 0x01, 0x00, 0x00,
		    0x00, 0x01, 0x00, 0x01, 0x02, 0x01, 0x01, 0x00,
		    0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00,
		    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
		    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
		    0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
		};
		var newtile4 = new byte[] {
		    0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
		    0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
		    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
		    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
		    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
		    0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
		};

		var tile1 = EncodeForPPU(newtile1);
		var tile2 = EncodeForPPU(newtile2);
		var tile3 = EncodeForPPU(newtile3);
		var tile4 = EncodeForPPU(newtile4);

		int cur_class = 0;
		Put(MAPMANGRAPHIC_OFFSET + (cur_class << 8) + (MAPMAN_DOWN * 16*4) + (16*0),  tile1);
		Put(MAPMANGRAPHIC_OFFSET + (cur_class << 8) + (MAPMAN_DOWN * 16*4) + (16*1),  tile2);
		Put(MAPMANGRAPHIC_OFFSET + (cur_class << 8) + (MAPMAN_DOWN * 16*4) + (16*2),  tile3);
		Put(MAPMANGRAPHIC_OFFSET + (cur_class << 8) + (MAPMAN_DOWN * 16*4) + (16*3),  tile4);
	    }
	}
}
